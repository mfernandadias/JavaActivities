Semana 5 ‚Äì Cole√ß√µes, Compara√ß√£o e Exce√ß√µes
Objetivo: Manipular dados em estruturas complexas.

Revis√£o de ArrayList
HashSet, TreeSet
HashMap, LinkedHashMap
equals(), hashCode()
Comparable e Comparator
Try-catch-finally

Exce√ß√µes personalizadas
üìå Exerc√≠cios: 20 exerc√≠cios com cole√ß√µes e tratamento de erros
üéØ Projeto pr√°tico: Agenda de contatos com busca e ordena√ß√£o


Revis√£o de ArrayList
ArrayList √© uma lista redimension√°vel que permite armazenar objetos em ordem
import java.util.ArrayList;

public class ExemploArrayList {
    public static void main(String[] args) {
        ArrayList<String> nomes = new ArrayList<>();
        nomes.add("Ana");
        nomes.add("Bruno");
        nomes.add("Carlos");

        System.out.println(nomes.get(0)); // Ana
        nomes.remove("Bruno");
        System.out.println(nomes.size()); // 2
    }
}

HashSet e TreeSet
HashSet n√£o permite elementos repetidos e n√£o garante ordem
TreeSet ordena automaticamente(requer que os elementos sejam compar√°veis)
import java.util.HashSet;
import java.util.TreeSet;

public class ExemploSet {
    public static void main(String[] args) {
        HashSet<String> frutas = new HashSet<>();
        frutas.add("Banana");
        frutas.add("Ma√ß√£");
        frutas.add("Banana"); // Ignorado

        TreeSet<String> frutasOrdenadas = new TreeSet<>(frutas);
        System.out.println(frutasOrdenadas); // [Banana, Ma√ß√£]
    }
}

HashMao e LinkedHashMap
HashMap armazena pares chave-valor sem ordem
LinkedHashMap mant√©m a ordem inser√ß√£o
import java.util.HashMap;
import java.util.LinkedHashMap;

public class ExemploMap {
    public static void main(String[] args) {
        HashMap<String, Integer> estoque = new HashMap<>();
        estoque.put("Arroz", 10);
        estoque.put("Feij√£o", 5);

        System.out.println(estoque.get("Arroz")); // 10

        LinkedHashMap<String, Integer> ordenado = new LinkedHashMap<>(estoque);
        ordenado.forEach((produto, qtd) -> System.out.println(produto + ": " + qtd));
    }
}

equals() e hashCode()
Usado para comparar objetos corretamente, especialmente em Set ou Map
import java.util.Objects;

class Pessoa {
    String nome;
    int idade;

    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Pessoa)) return false;
        Pessoa pessoa = (Pessoa) o;
        return idade == pessoa.idade && nome.equals(pessoa.nome);
    }

    @Override
    public int hashCode() {
        return Objects.hash(nome, idade);
    }
}

Comparable e Comparator
Comparable<T>: define ordem natural (com compareTo)

Comparator<T>: define outras ordens (com compare)
import java.util.*;

class Produto implements Comparable<Produto> {
    String nome;
    double preco;

    public Produto(String nome, double preco) {
        this.nome = nome;
        this.preco = preco;
    }

    @Override
    public int compareTo(Produto outro) {
        return nome.compareTo(outro.nome);
    }
}

class ComparadorPorPreco implements Comparator<Produto> {
    public int compare(Produto p1, Produto p2) {
        return Double.compare(p1.preco, p2.preco);
    }
}

public class ExemploComparacao {
    public static void main(String[] args) {
        List<Produto> lista = new ArrayList<>();
        lista.add(new Produto("Mouse", 25.0));
        lista.add(new Produto("Teclado", 45.0));

        Collections.sort(lista); // ordena por nome
        lista.sort(new ComparadorPorPreco()); // ordena por pre√ßo
    }
}

6. Try-catch-finally
Tratamento de erros e exce√ß√µes
public class ExemploExcecao {
    public static void main(String[] args) {
        try {
            int resultado = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("Erro: divis√£o por zero");
        } finally {
            System.out.println("Fim do programa");
        }
    }
}

Exce√ß√µes Personalizadas
Crie sua pr√≥pria exce√ß√£o estendendo Exception ou Runt